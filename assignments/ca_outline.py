
from __future__ import annotations

from itertools import chain, repeat
from typing import List
from copy import copy

import numpy as np
from random import choice

import core.gui as gui
from core.gui import HOR_SEP
from core.on_off import OnOffPatch, OnOffWorld, on_off_left_upper  
from core.sim_engine import gui_get, gui_set
from core.utils import bin_str


class CA_World(OnOffWorld):

    ca_display_size = 110

    # bin_0_to_7 is ['000' .. '111']
    bin_0_to_7 = [bin_str(n, 3) for n in range(8)]

    '''
    Design/Strategy:
    generate the dictionary containing the number from 1 to 128 as well as its rule form.
    set the initial rule number so that the switches and binary number can be set from it.
    then generate a list that will contain lists, which will containg the values in the grid lines.

    code: given below

    Review:
        this method makes use of list comprehension to be able to save the values directly into a list, rather than using a separate for loop. this saves lines of code, which make it more readable.
        Other than that, it uses simple lines of code and is very readable

    Testing:
        check that the rule number align with the switches and slider as well as the binary representation at startup.
        Also print the variable pos_to_switch to make sure it has the right key vallue pairs

    '''

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        # self.pos_to_switch is a dictionary that maps position values in a binary number to range(8) represented
        # as 3-digit binary strings:
        #     {1: '000', 2: '001', 4: '010', 8: '011', 16: '100', 32: '101', 64: '110', 128: '111'}
        # The three digits are the rule components and the keys to the switches.
        # To see it, try: print(self.pos_to_switch) after executing the next line.
        # The function bin_str() is defined in utils.py

        # The following two lines do the same thing. Explain how both work.
        # self.pos_to_switch0 = {2**i: bin_str(i, 3) for i in range(8)}
        self.pos_to_switch = dict(zip([2**i for i in range(8)], CA_World.bin_0_to_7))

        # The rule number used for this run, initially set to 110 as the default rule.
        # (You might also try rule 165.)
        # The following sets the local variable self.rule_nbr. It doesn't change the 'Rule_nbr' slider widget.
        self.rule_nbr = 110
        # Set the switches and the binary representation of self.rule_nbr.
        self.set_switches_from_rule_nbr()
        self.set_binary_nbr_from_rule_nbr()
        gui_set('Rule_nbr', value=self.rule_nbr)

        # self.ca_lines is a list of lines, each of which is a list of 0/1. Each line represents
        # a state of the CA, i.e., all the cells in the line. self.ca_list contains the entire
        # history of the CA.
        # !  List of ines that is initialized to an empty list. The values from the nested list get copied to patches for each line
        self.ca_lines: List[List[int]] = []
        # ! Sets the rows number based on how many lists are nested inside of self.ca_lines
        gui_set('rows', value=len(self.ca_lines))

        # BY <ABRAN LEZAMA>

    def build_initial_line(self):
        """
        Construct the initial CA line.
        It is a random line if gui_get('Random?').
        It is a line (of length ca_display_size) if gui_get('init_line') == ''.
        Otherwise it is the string in gui_get('init_line') converted into 0's and 1's.
        (' ' and '0' are converted to 0; everything else is converted to 1.) 
        However, if the rule includes 000 -> 1,pad the line with 0's on both ends to fill the display.
        How much to put on each end depends on the user-specific initial line and the requested justification.
        """

        '''
        Design/Strategy:

            first check if the user checked the random box so that a line with random 0's and 1's can be generated
            if rndom was not selected and no input by use was given in box initial row, fill the first line with 0's
            if input was give by user, get it from initial row box and add add them as integer values to a list
            check if rule 000 was checked, because if it was checked we need to generate a padding to fill the line.
            the actual_padding is generated by looking at line_len to see how many places available there are, and that is why line_len depends on rule 000.
            the padding is either placed on the left, center, or right depending on the justification given by user.

        Code: given below

        Review:
            To generate the random line if the random checkbox is clicked a list comprehension isused.
            This allows us to fit multiple line content into a single line.
            The rest of the code implements simple operations and follow appropiate indentations.
        
        Testing:
            the initial line should be testing on multiple justifications to ensure that the padding is 
            being added to the right position based on the specified justification
            
        '''
        # ! OUR EXPLANATION
        # ! if random is clicked, the first line is randomly filled with 0's and 1's
        # ! if random is not clicked and the user does not input a pattern in initial row, the whole line is filled with 0's
        # ! if initial pattern in provided, add it into a list
        # ! when rule 000 is applied we add padding depending on the justification to fill the line
        # ! line_len is made to depend on 000 because if that rule is applied, we have to know how many
        # ! 0's or 1's the user entered so that we can fill the rest of the line with padding depending on the justification
        self.ca_lines.append([])
        if gui_get('Random?'):
            line = [choice([0, 1]) for _ in range(self.ca_display_size)]
            #line = ''.join([choice(['0', '1']) for _ in range(self.ca_display_size)])
        else:
            # A line of 0's.
            padding = [0] * (self.ca_display_size)
            if gui_get('init_line') == '':
                line = padding
            else:
                line_0 = gui_get('init_line')
                # Convert line_0 to 0's and 1's
                line = [0 if c in ' 0' else 1 for c in line_0] 
                # If the rule include 000 -> 1, fill out the new line with 0's.
                if gui_get('000'):
                    justification = gui_get('justification')
                    line_len = len(line)
                    actual_padding = padding[line_len:]
                    line = actual_padding + line if justification == 'Right' else \
                           line + actual_padding if justification == 'Left' else \
                           actual_padding[len(actual_padding) // 2:] + line + \
                           actual_padding[len(actual_padding) // 2:] #  justification == 'Center'

        print(line)
        ''' 
        THIS HAPPENS FOR WHEN THE JUSTIFICATION IS CENTERED AND RULE 000 IS CHECKED
        display_size = 10
        line_len = 3  --> 4 + 3 + 4 = 11 --> greater than display_size since the actual padding in odd
        line_len = 2 ---> 4 + 2 + 4 = 10 --> the same as the dipsly_size since the actual padding is even

        '''

        return line

        # BY <ABRAN LEZAMA>

    '''
    Design/Strategy:
        check if the first element and last element in new_line is 0, if they are, remove them

    Code: provided below

    Review:
        this method impleents simple logoc, with good indentation for the method to work properly

    Testing:
        One would test of the first and last line of the new_line ar eactually removed if they are 0
    '''
    # ! the static method measn that an instance creation is not required, they are bound to the class instead of instances of such class.
    # ! this method basically remoes the first and last element of a new list if they are 0
    @staticmethod
    def drop_extraneous_0s_from_ends_of_new_line(new_line):
        """
        Drop the end cell at each end of new_line if it is 0. Keep it otherwise.
        Return the result.
        Args:
            new_line: ca_state with perhaps extraneous 0 cells at the ends

        Returns: trimmed ca_state without extraneous 0 cells at the ends.
        """
        if new_line[0] == 0:
            new_line.pop(0)
        if new_line[-1] == 0:
            new_line.pop(-1)
        return new_line
    
    # BY <ABRAN LEZAMA>

    '''
    Design/Strategy:
        firch cehck if the first or last elemen in new_list is 1.
        if that is the case, insert a 0 at the end of each line in ca_lines
        this is done by looping through each line in ca_lines

    Code: code is provided below

    Review:
        The method uses simple logic. Other than that, it uses proper indentation for the method to work

    Testing:
        one would test if the if the 0 is inserted at the corresponding end of each line in ca_lines if they are 0.
        otherwise, the method does not does not work properly
    '''

    # ! the static method measn that an instance creation is not required, they are bound to the class instead of instances of such class.
    # ! this method basically extends caline_line if needed
    def extend_ca_lines_if_needed(self, new_line):
        """
        new_line is one cell longer at each end than ca_lines[-1]. If those extra
        cells are 0, delete them. If they are 1, insert a 0 cell at the corresponding
        end of each line in ca_lines.
        """
        if new_line[0] == 1 or new_line[-1] == 1:
            for line in self.ca_lines:
                if new_line[0]:
                    line.insert(0, 0)
                if new_line[-1]:
                    line.append(0)

    # BY <ABRAN LEZAMA>



    @staticmethod
    def generate_new_line_from_current_line(prev_line):
        """
        The argument is (a copy of) the current line, i.e., copy(self.ca_lines[-1]).
        We call it prev_line because that's the role it plays in this method.
        Generate the new line in these steps.
        1. Add 0 to both ends of prev_line. (We do that because we want to allow the
        new line to extend the current line on either end. So start with a default extension.
        2. Insert an additional 0 at each end of prev_line. That's because we need a triple
        to generate the cells at the end of the new line. So, by this time the original
        line has been extended by [0, 0] on both ends.
        3. Apply the rules (i.e., the switches) to the result of step 2. This produces a line
        which is one cell shorter than the current prev_line on each end. That is, it is
        one cell longer on each end than the original prev_line.
        4. Return that newly generated line. It may have 0 or 1 at each end.
        Args:
            prev_line: The current state of the CA.
        Returns: The next state of the CA.
        """
        # Extend the current line two to the left and right.
        # Want to be able to generate one additional value at each end.
       
        #prev_line = '00' + prev_line + '00'  
        #new_line_chars = [str(int(gui_get(prev_line[i:i + 3]))) for i in range(len(prev_line) - 2)]
        #new_line = ''.join(new_line_chars)
       
        prev_line.insert(0,0)
        prev_line.insert(0,0)
        prev_line.append(0)
        prev_line.append(0)
        triples = [''.join(map(str, prev_line[i:i+3])) for i in range(len(prev_line) - 2)]
        new_line = [int(gui_get(triple)) for triple in triples]
        return new_line

    def get_rule_nbr_from_switches(self):
        """
        Translate the on/off of the switches to a rule number.
        This is the inverse of set_switches_from_rule_nbr(), but it doesn't set the 'Rule_nbr' Slider.
        """

        nubers = [1, 2, 4, 8, 16, 32, 64, 128]
        new_rule_nbr = 0
        for i in range(0, 8):
            if gui_get(self.bin_0_to_7[i]):
                new_rule_nbr += nubers[i]
        return new_rule_nbr


    '''
    Design/Strategy:
        this method makes use of the onofworld class to handle the events,
        it checks if there have been changes in the rule number
        if there have been changes, make sure that everything is the same by calling self.make_switches_and_rule_nbr_consistent()
        also check if the random checkbox is clikced, if it is  disappear the initial row box where the user enters the initial pattern.

    Code: given below

    Review:
        this method as well uses simple logic and is formatted well, which makes it readable

    Testing: 
        this method can be tested by making sure that the events are trigerred when there is a change in the rule number
        either thorugh the slider or switches

    '''


    # ! this method basically allows us to make changes based on changes on the slider and switches.
    # ! this method is called from on_off.py file inside the class onOfWorld. I think that is also
    # ! why super is used since this class extends from that class and is implementing a method from its parent in a way.
    def handle_event(self, event):
        """
        This is called when a GUI widget is changed and the change isn't handled by the system.
        The key of the widget that changed is in event.
        """
        # Handle color change requests.
        super().handle_event(event)

        # Handle rule nbr change events, either switches or rule_nbr slider
        if event in ['Rule_nbr'] + CA_World.bin_0_to_7:
            self.make_switches_and_rule_nbr_consistent()

        # When the user checks the 'Random?' box, the Input line area should disappear.
        # When the user unchecks the 'Random?' box, the Input line area should re-appear.
        elif event == 'Random?':
            disabled = gui_get('Random?')
            gui_set('init_line', visible= not disabled, value=1)

    # BY <ABRAN LEZAMA>

    '''
    Design/Strategy:
        the straategy is check if the the current number in the switches is the same as the rule_number
        if it is not, set the rule number to the number in the switches because tha is the dominant one.
        Also set the slider be consistent with the switches
        Also check if the slider changes, if it does, set its value to the rule number and also adjust the switches
        lastly, the binarly number format always changes based on what the current rule numbe is on the slider.
    Code: code is given below

    Review:
        This method as well only depends on some conditional. Additionally, the code is formated well

    Testing:
        To test it, check that all are in sync, meaning that when one thing changes, the rest also change.
    '''
    def make_switches_and_rule_nbr_consistent(self):
        """
        Make the Slider, the switches, and the bin number consistent: all should contain self.rule_nbr.
        """
        current_switches_nbr = self.get_rule_nbr_from_switches()

        # ** switches number and rule number are not the same
        if current_switches_nbr != self.rule_nbr:
            self.rule_nbr = current_switches_nbr
            gui_set('Rule_nbr', value=self.rule_nbr)
        else:
        # ** the slider changed
            self.rule_nbr = gui_get('Rule_nbr')
            self.set_switches_from_rule_nbr()
        # ** update the binary number for any change in rule number
        self.set_binary_nbr_from_rule_nbr()
    
    # BY <ABRAN LEZAMA>

    '''
    Design/Strategy:
        set the binary number on the gui equal to the binary version of the rule number.

    Code: given below

    Review:
        I think it follows good form this code because it is readable and everything is compacted into a single line
    
    Testing:
        check that the binary representation of the rule number is accurate when the slider or switches are changed.
    '''

    def set_binary_nbr_from_rule_nbr(self):
        """
        Translate self.rule_nbr into a binary string and put it into the
        gui.WINDOW['bin_string'] widget. For example, if self.rule_nbr is 110,
        the string '(01101110)' is stored in gui.WINDOW['bin_string']. Include
        the parentheses around the binary number.

        Use gui_set('bin_string', value=new_value) to update the value of the widget.
        """

        gui_set('bin_string', value=bin(self.rule_nbr)[2:].zfill(8))

    # BY <ABRAN LEZAMA>
        

    def set_display_from_lines(self):
        """
        Copy values from self.ca_lines to the patches. There are two issues.
        1. Is self.ca_lines longer/shorter than the number of Patch rows in the display?
        2. Are there more/fewer cells-per-line than Patches-per-row?
        What do you do in each case?

        This is the most difficult method. Here is the outline I used.
        """
        # Get the current setting of 'justification'.
        justification = gui_get('justification')

        # Get the two relevant widths.
        display_width = gui.PATCH_COLS

        # All the lines in self.ca_lines are the same length.
        ca_line_width = len(self.ca_lines[0])

        # How many blanks must be prepended to a line to be displayed to fill a display row?
        # Will be 0 if the ca_line is at least as long as the display row or the line is left-justified.
        left_padding_needed = 0 if ca_line_width >= display_width or justification == 'Left' else \
                              (display_width - ca_line_width) // 2 if justification == 'Center' else \
                              display_width - ca_line_width

        # Use [0]*n to get a list of n 0s to use as left padding.
        left_padding = [0]*left_padding_needed

        # Which elements of the ca_line are to be displayed?
        # More to the point, what is index of the first element of the line to be displayed?
        # Will be 0 if left_padding is the empty list. Otherwise compute the values for the other cases.
        left_ca_line_index = 0 if display_width >= ca_line_width or justification == 'Left' else \
                             (ca_line_width - display_width) // 2 if justification == 'Center' else \
                             ca_line_width - display_width

        # Reverse both self.ca_lines and CA_World.patches_array.
        ca_lines_to_display = reversed(self.ca_lines)
        patch_rows_to_display_on = np.flip(CA_World.patches_array, axis=0)

        # Now we can use zip to match up ca_lines_to_display and patch_rows_to_display on.
        # In both cases we are starting at the bottom and working our way up.
        ca_lines_patch_rows = zip(ca_lines_to_display, patch_rows_to_display_on)

        # zip is given two iterables and produces a sequence of pairs of elements, one from each.
        # An important feature of zip is that it stops whenever either of its arguments ends.
        # In particular, the two arguments needn't be the same length. Zip simply uses all the elements
        # of the shorter argument and pairs them with the initial elements of the longer argument.

        # We can now step through the corresponding pairs.
        for (ca_line, patch_row) in ca_lines_patch_rows:
            # The values in ca_line are to be displayed on patch_row.
            # The issue now is how to align them.

            # Which elements of ca_line should be displayed?
            # We display all the elements starting at left_ca_line_index (computed above).
            # Use a slice to identify these elements.
            ca_line_portion = ca_line[left_ca_line_index:]

            # For the complete display line and the desired justification,
            # we may need to pad ca_line_portion to the left or right (or both).
            # We need left_padding (computed above) to the left and an arbitrary sequence of 0's to the right.
            # (Use repeat() from itertools for the padding on the right. It doesn't matter if it's too long!)

            # Put the three pieces together to get the full line.
            # Use chain() from itertools to combine the three parts of the line:
            #          left_padding, ca_line_portion, right_padding.
            padded_line = chain(left_padding, ca_line_portion, repeat('0'))

            # padded_line has the right number of 0's at the left. It then contains the elements from ca_line
            # to be displayed. If we need more elements to display, padded_line includes an unlimted number of
            # trailing 0's.

            # Since padded_line will be displayed on patch_row, we can use zip again to pair up the values
            # from padded_line with the Patches in patch_row. Since padded_line includes an unlimited number
            # of 0's at the end, zip will stop when it reaches the last Patch in patch_row.

            ca_values_patchs = zip(padded_line, patch_row)

            # Step through these value/patch pairs and put the values into the associated Patches.
            for (ca_val, patch) in ca_values_patchs:
                # Use the set_on_off() method of OnOffPatch to set the patch to ca_val.
                patch.set_on_off(ca_val)

    
    # BY <ABRAN LEZAMA>
    # Assisted by <Brandon >

    '''
    Design/Strategy:
        so first we need to know the current rule number, then we loop though the post_to_switch because we want to have access to 000....111 to be able to check them in the guy
        we do this by using module on the rule number, it we get a remainder we check the box, else no.
        modles 2 is used because the numbers for each switch is a multiple of 2
        divide the rule number by 2 and repeat the process.
    
    Code:
        given below
    
    review:
        This method also is really simple. It follows good format and everything is very readable

    Testing:    
        Check that the switches are checked correctly based on what the current rule number is
    '''

    def set_switches_from_rule_nbr(self):
        """
        Update the settings of the switches based on self.rule_nbr.
        Note that the 2^i position of self.rule_nbr corresponds to self.pos_to_switch[i]. That is,
        self.pos_to_switch[i] returns the key for the switch representing position  2^i.

        Set that switch as follows: gui_set(self.pos_to_switch[pos], value=new_value).
        (new_value will be either True or False, i.e., 1 or 0.)

        This is the inverse of get_rule_nbr_from_switches().
        """
        ...
        rule_nbr = self.rule_nbr
        for i in self.pos_to_switch:
            gui_set(self.pos_to_switch[i], value=rule_nbr % 2)
            rule_nbr = rule_nbr // 2

    
    '''
    Design/Strategy:
        after the slider and the switches are all the same, the initial line of the frid is generated when the setup button is clicked.
        Also the set_display_from_line is called to form the initial line

    code: given below

    Review: 
        This method is also really simple. It follow good format which makes it readable

    Testing:
        check that the initial line is generated when the setup button is clicked. Otherwise, something is wrong.
    '''
    def setup(self):
        """
        Make the slider, the switches, and the bin_string of the rule number consistent with each other.
        Give the switches priority.
        That is, if the slider and the switches are both different from self.rule_nbr,
        use the value derived from the switches as the new value of self.rule_nbr.

        Once the slider, the switches, and the bin_string of the rule number are consistent,
        set self.ca_lines[0] to the line generated by build_initial_line.
        """

        # ! elif SimEngine.event == self.simple_gui.SETUP:
        # ! the line above is appear in file sim_engine.py line 149


        # self.make_switches_and_rule_nbr_consistent()
        self.ca_lines = [self.build_initial_line()]
        self.set_display_from_lines()



        # print(gui_get('init_line'))
        # print([choice([0, 1]) for _ in range(self.ca_display_size)])


    def step(self):
        """
        Take one step in the simulation.
        (a) Generate an additional line for the ca. (Use a copy of self.ca_lines[-1].)
        (b) Extend all lines in ca_lines if the new line is longer (with additional 1's) than its predecessor.
        (c) Trim the new line and add to self.ca_lines
        (d) Refresh display from values in self.ca_lines.
        """
        # (a)
        new_line: str = self.generate_new_line_from_current_line(copy(self.ca_lines[-1])) # The new state derived from self.ca_lines[-1]

        # (b)
        # Extend lines in self.ca_lines at each end as needed.
        # (Don't extend for extra 0's at the ends.)
        # Can't do step (c) first because we would lose track of which end was extended.
        self.extend_ca_lines_if_needed(new_line)

        # (c)
        # Drop extraneous 0s at the end of new_line
        trimmed_new_line = self.drop_extraneous_0s_from_ends_of_new_line(new_line)
        # Add trimmed_new_line to the end of self.ca_lines
        self.ca_lines.append(trimmed_new_line)

        # (d)
        # Refresh the display from self.ca_lines
        self.set_display_from_lines()
        # Update the 'rows' widget.
        gui_set('rows', value=len(self.ca_lines))


# ############################################## Define GUI ############################################## #
import PySimpleGUI as sg

'''
Design/Strategy:
    sg.Text provides text field
    sg.Combo provides a drop down box with values for [left, right, center]
    HOR_SEP provides horizontal padding
    sg.Input provides an input field for the user
    sg.CB provides checkbox elements
    on_off_left_upper provides functionality to select colors, begins setup for event handlers
Code: 
    uses multiple resources from on_off.py
Review:
    very few issues with PEP-8 as it is spaced out for readability.
    Naming conventions are utilized where able. 
    PySimpleGUI breaks PEP-8 by using capilalized letters for function names, opposed to classes
    still, this issue is not too cumbersome.
Testing:
    while attempting to remove portions of the gui, we ran into some errors where:
            rows are shifted or missing
            code does not compile properly
            since Python is a scripting language the program will run but not execute
'''

""" 
The following appears at the top-left of the window. 
"""
ca_left_upper = \
    [[sg.Text('Row justification'),
      sg.Combo(values=['Left', 'Center', 'Right'], key='justification', default_value='Right')],

     HOR_SEP(30),

     [sg.Text('Initial row:', pad=((0, 10), (20, 10)),
              tooltip="0's and 1's for the initial row. An empty \n" +
                      "string will set the initial row to all 0's."),
      sg.Input(default_text="1", key='init_line', size=(20, None), text_color='white',
               background_color='steelblue4', justification='center')],

     [sg.CB('Random?', key='Random?', enable_events=True, pad=((75, 0), None),
            tooltip="Set the initial row to random 0's and 1's.")],

     HOR_SEP(30, pad=(None, None)),

     [sg.Text('Rows:', pad=(None, (10, 0))), sg.Text('     0', key='rows', pad=(None, (10, 0)))],

     HOR_SEP(30, pad=(None, (0, 10)))

     ] + on_off_left_upper


# The switches are CheckBoxes with keys from CA_World.bin_0_to_7 (in reverse).
# These are the actual GUI widgets, which we access via their keys.
# The pos_to_switch dictionary maps position values in the rule number as a binary number
# to these widgets. Each widget corresponds to a position in the rule number.
# Note how we generate the text for the chechboxes.
switches = [sg.CB(n+'\n 1', key=n, pad=((30, 0), (0, 0)), enable_events=True) for n in reversed(CA_World.bin_0_to_7)]

'''
Design/Strategy:
    sg.Text provides text field
    sg.Slider provides a slide ruler that can be used for multiple values
    switches (defined above) are the binary representation for the slider values
Code: 
    uses multiple resources from CA_World.bin_0_to_7
Review:
    very few issues with PEP-8 as it is spaced out for readability.
    Naming conventions are utilized where able. 
    PySimpleGUI breaks PEP-8 by using capilalized letters for function names, opposed to classes
    still, this issue is not too cumbersome.
Testing:
    Not much testing to be done other than for readability and debugging
'''

""" 
This  material appears above the screen: 
the rule number slider, its binary representation, and the switch settings.
"""
ca_right_upper = [[sg.Text('Rule number', pad=((100, 0), (20, 10))),
                   sg.Slider(key='Rule_nbr', range=(0, 255), orientation='horizontal',
                             enable_events=True, pad=((10, 20), (0, 10))),
                   sg.Text('00000000 (binary)', key='bin_string', enable_events=True, pad=((0, 0), (10, 0)))],

                  switches
                  ]


if __name__ == "__main__":
    """
    Run the CA program. PyLogo is defined at the bottom of core.agent.py.
    """
    from core.agent import PyLogo

    # Note that we are using OnOffPatch as the Patch class. We could define CA_Patch(OnOffPatch),
    # but since it doesn't add anything to OnOffPatch, there is no need for it.
    PyLogo(CA_World, '1D CA', patch_class=OnOffPatch,
           gui_left_upper=ca_left_upper, gui_right_upper=ca_right_upper, auto_setup=False,
           fps=10, patch_size=3, board_rows_cols=(CA_World.ca_display_size, CA_World.ca_display_size))
